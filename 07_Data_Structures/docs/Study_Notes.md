# 学习笔记：数据结构与算法 (Data Structures and Algorithms)

这份文档用于记录《数据结构与算法》课程的学习心得、核心概念整理、实验记录以及待解决的问题。

---

## Module 1: 算法分析与复杂度理论

### 1.1 核心概念速查
*   **时间复杂度 (Time Complexity)**:
    *   **定义**: 算法执行时间随输入规模增长的变化趋势
    *   **渐近记号**:
        *   **O (大O)**：上界，表示最坏情况下的复杂度
        *   **Ω (大Ω)**：下界，表示最好情况下的复杂度
        *   **Θ (大Θ)**：紧界，表示平均情况下的复杂度
    *   **常见复杂度排序**:
        *   O(1) < O(log n) < O(n) < O(n log n) < O(n²) < O(2ⁿ) < O(n!)
*   **递归算法分析**:
    *   **主定理 (Master Theorem)**:
        *   适用于形如 T(n) = aT(n/b) + f(n) 的递归式
        *   其中 a ≥ 1, b > 1, f(n) 是正函数
    *   **主定理的三种情况**:
        1.  如果 f(n) = O(n^{log_b a - ε})，则 T(n) = Θ(n^{log_b a})
        2.  如果 f(n) = Θ(n^{log_b a})，则 T(n) = Θ(n^{log_b a} log n)
        3.  如果 f(n) = Ω(n^{log_b a + ε})，且 a f(n/b) ≤ c f(n)，则 T(n) = Θ(f(n))
*   **分摊分析 (Amortized Analysis)**:
    *   **定义**: 考虑一系列操作的平均时间复杂度
    *   **方法**: 聚集分析、会计方法、势能方法
    *   **示例**: 动态数组的扩容操作，均摊时间复杂度为 O(1)

### 1.2 重点难点记录
- [ ] 如何区分渐近记号中的上界、下界和紧界？
- [ ] 主定理的适用条件是什么？有哪些例外情况？
- [ ] 为什么快速排序的平均时间复杂度是 O(n log n)，而最坏情况是 O(n²)？

### 1.3 实验记录
*   **时间复杂度分析实践**:
    *   实现了线性查找和二分查找算法
    *   测量并对比了不同输入规模下的执行时间
    *   验证了理论复杂度分析的正确性

---

## Module 2: 基本数据结构

### 2.1 核心概念速查
*   **数组 (Arrays)**:
    *   **静态数组**: 大小固定，随机访问时间 O(1)
    *   **动态数组 (Vector)**:
        *   自动扩容，通常采用二倍扩容策略
        *   插入/删除末尾元素：O(1) 均摊时间
        *   插入/删除中间元素：O(n) 时间
*   **链表 (Linked Lists)**:
    *   **单链表**: 每个节点包含数据和指向下一个节点的指针
    *   **双链表**: 每个节点包含数据和指向前后节点的指针
    *   **循环链表**: 最后一个节点指向第一个节点
    *   **操作时间复杂度**:
        *   插入/删除头节点：O(1)
        *   插入/删除中间节点：O(n)
        *   查找元素：O(n)
*   **栈 (Stacks)**:
    *   **特性**: 后进先出 (LIFO, Last-In-First-Out)
    *   **基本操作**:
        *   push: 入栈，O(1)
        *   pop: 出栈，O(1)
        *   peek: 查看栈顶元素，O(1)
    *   **应用**: 括号匹配、函数调用栈、表达式求值
*   **队列 (Queues)**:
    *   **特性**: 先进先出 (FIFO, First-In-First-Out)
    *   **基本操作**:
        *   enqueue: 入队，O(1)
        *   dequeue: 出队，O(1)
        *   front: 查看队首元素，O(1)
    *   **应用**: 广度优先搜索、任务调度

### 2.2 重点难点记录
- [ ] 为什么动态数组的扩容策略通常是二倍而不是三倍或其他倍数？
- [ ] 如何用单链表实现栈和队列？
- [ ] 循环链表和双链表在什么场景下比单链表更有优势？

### 2.3 实验记录
*   **动态数组实现**:
    *   实现了支持动态扩容的数组类
    *   验证了二倍扩容策略的均摊时间复杂度
*   **链表操作**:
    *   实现了单链表和双链表
    *   完成了插入、删除、反转等操作

---

## Module 3: 树与二叉搜索树

### 3.1 核心概念速查
*   **树的基本概念**:
    *   **节点 (Node)**: 树的基本单位，包含数据和子节点指针
    *   **根节点 (Root)**: 树的最顶层节点
    *   **叶子节点 (Leaf)**: 没有子节点的节点
    *   **高度 (Height)**: 节点到叶子节点的最长路径长度
    *   **深度 (Depth)**: 节点到根节点的路径长度
*   **二叉树遍历**:
    *   **前序遍历 (Pre-order)**: 根 → 左 → 右
    *   **中序遍历 (In-order)**: 左 → 根 → 右
    *   **后序遍历 (Post-order)**: 左 → 右 → 根
    *   **层序遍历 (Level-order)**: 按层从上到下，每层从左到右
*   **二叉搜索树 (BST)**:
    *   **性质**: 左子树所有节点 < 根节点 < 右子树所有节点
    *   **基本操作**:
        *   插入 (Insert): O(h)，h 为树高
        *   查找 (Search): O(h)
        *   删除 (Delete): O(h)，需要处理三种情况
    *   **平衡问题**: 不平衡的 BST 可能退化为链表，时间复杂度变为 O(n)
*   **平衡二叉树**:
    *   **AVL树**:
        *   左右子树高度差不超过 1
        *   通过旋转操作保持平衡：左旋、右旋、左右旋、右左旋
    *   **红黑树**:
        *   满足五条性质：节点非红即黑、根节点为黑、叶子节点为黑、红节点的子节点为黑、任意节点到叶子节点的黑节点数相同
        *   插入和删除操作通过旋转和变色保持平衡
    *   **堆 (Heap)**:
        *   **最大堆**: 父节点 ≥ 子节点
        *   **最小堆**: 父节点 ≤ 子节点
        *   **基本操作**: 插入 (O(log n))、删除堆顶 (O(log n))

### 3.2 重点难点记录
- [ ] 为什么中序遍历二叉搜索树可以得到有序序列？
- [ ] AVL树和红黑树各有什么优缺点？在实际应用中如何选择？
- [ ] 如何实现堆的建堆操作？时间复杂度是多少？

### 3.3 实验记录
*   **二叉搜索树实现**:
    *   实现了BST的插入、删除、查找操作
    *   实现了四种遍历算法
*   **平衡二叉树实验**:
    *   实现了AVL树的旋转操作
    *   对比了AVL树和普通BST的性能差异

---

## Module 4: 哈希表与散列技术

### 4.1 核心概念速查
*   **哈希函数 (Hash Function)**:
    *   **定义**: 将任意大小的输入映射到固定大小的输出
    *   **设计原则**: 一致性、高效性、均匀性、抗碰撞性
    *   **常见哈希函数**:
        *   直接定址法、数字分析法、平方取中法、折叠法、除留余数法
        *   字符串哈希：DJB2、FNV-1a、MurmurHash
*   **冲突解决 (Collision Resolution)**:
    *   **链地址法 (Chaining)**:
        *   将哈希值相同的元素存储在同一个链表中
        *   平均查找时间复杂度：O(1 + α)，α 为负载因子
    *   **开放寻址法 (Open Addressing)**:
        *   线性探测 (Linear Probing): h(k, i) = (h(k) + i) mod m
        *   二次探测 (Quadratic Probing): h(k, i) = (h(k) + i²) mod m
        *   双重哈希 (Double Hashing): h(k, i) = (h1(k) + i h2(k)) mod m
    *   **负载因子 (Load Factor)**:
        *   **定义**: α = n/m，其中 n 为元素个数，m 为哈希表大小
        *   **扩容策略**: 当 α 超过阈值（通常为 0.75）时，扩容哈希表

### 4.2 重点难点记录
- [ ] 如何设计一个好的哈希函数？
- [ ] 链地址法和开放寻址法各有什么优缺点？
- [ ] 为什么哈希表的扩容通常采用二倍扩容策略？

### 4.3 实验记录
*   **哈希表实现**:
    *   使用链地址法实现了哈希表
    *   实现了插入、查找、删除操作
    *   测试了不同负载因子下的性能

---

## Module 5: 图算法基础

### 5.1 核心概念速查
*   **图的表示**:
    *   **邻接矩阵 (Adjacency Matrix)**:
        *   空间复杂度：O(V²)
        *   适合稠密图
        *   判断边是否存在：O(1)
    *   **邻接表 (Adjacency List)**:
        *   空间复杂度：O(V + E)
        *   适合稀疏图
        *   遍历邻接节点：O(degree(v))
*   **图的遍历**:
    *   **深度优先搜索 (DFS)**:
        *   **特点**: 尽可能深地搜索，回溯
        *   **实现**: 递归或栈
        *   **时间复杂度**: O(V + E)
        *   **应用**: 拓扑排序、强连通分量
    *   **广度优先搜索 (BFS)**:
        *   **特点**: 按层搜索
        *   **实现**: 队列
        *   **时间复杂度**: O(V + E)
        *   **应用**: 最短路径（无权图）
*   **最短路径算法**:
    *   **Dijkstra算法**:
        *   适用于非负权图
        *   时间复杂度：O(E log V)（使用优先队列）
        *   思想：贪心算法，每次选择距离最近的节点
    *   **Bellman-Ford算法**:
        *   适用于含负权边的图
        *   时间复杂度：O(V E)
        *   可以检测负权环
*   **最小生成树 (MST)**:
    *   **定义**: 连接所有顶点且总权值最小的树
    *   **Kruskal算法**:
        *   **思想**: 贪心算法，按权值从小到大选择边，使用并查集检测环
        *   时间复杂度：O(E log E)
    *   **Prim算法**:
        *   **思想**: 贪心算法，从一个顶点开始，逐步扩展MST
        *   时间复杂度：O(E log V)（使用优先队列）

### 5.2 重点难点记录
- [ ] Dijkstra算法为什么不能处理负权边？
- [ ] Kruskal算法和Prim算法有什么区别？各自适用于什么场景？
- [ ] 如何检测图中是否存在环？

### 5.3 实验记录
*   **图的表示与遍历**:
    *   实现了邻接矩阵和邻接表表示
    *   实现了DFS和BFS算法
*   **最短路径算法**:
    *   实现了Dijkstra算法和Bellman-Ford算法
    *   对比了两种算法的性能和适用场景

---

## Module 6: 高级数据结构与算法

### 6.1 核心概念速查
*   **字典树 (Tries)**:
    *   **定义**: 前缀树，用于高效存储和检索字符串集合
    *   **基本操作**:
        *   插入：O(m)，m 为字符串长度
        *   查找：O(m)
        *   前缀匹配：O(m)
    *   **应用**: 自动完成、拼写检查、IP路由
*   **线段树 (Segment Trees)**:
    *   **定义**: 用于区间查询和更新的二叉树结构
    *   **基本操作**:
        *   构建：O(n)
        *   区间查询：O(log n)
        *   单点更新：O(log n)
        *   区间更新：O(log n)（使用延迟标记）
    *   **应用**: 区间和查询、区间最大值查询、区间更新
*   **树状数组 (Fenwick Trees / Binary Indexed Trees)**:
    *   **定义**: 用于前缀和查询和单点更新的高效数据结构
    *   **基本操作**:
        *   构建：O(n)
        *   前缀和查询：O(log n)
        *   单点更新：O(log n)
    *   **应用**: 频率统计、逆序对计数
*   **并查集 (Disjoint Set Union / Union-Find)**:
    *   **定义**: 用于处理集合合并与查询的树型数据结构
    *   **基本操作**:
        *   查找 (Find): O(α(n))，α 为阿克曼函数的反函数
        *   合并 (Union): O(α(n))
    *   **优化**: 路径压缩、按秩合并
    *   **应用**: 连通性问题、最小生成树算法

### 6.2 重点难点记录
- [ ] 线段树和树状数组有什么区别？各自的优势是什么？
- [ ] 如何实现线段树的区间更新操作？
- [ ] 并查集的路径压缩和按秩合并优化原理是什么？

### 6.3 实验记录
*   **高级数据结构实现**:
    *   实现了字典树，用于字符串前缀匹配
    *   实现了树状数组，用于前缀和查询
*   **算法应用**:
    *   使用并查集解决了连通性问题
    *   使用线段树解决了区间查询问题

# 学习笔记：编译原理 - GCC/RISC-V工具链 (Compiler Construction - GCC/RISC-V Toolchain)

这份文档用于记录《编译原理 - GCC/RISC-V工具链》课程的学习心得、核心概念整理、实验记录以及待解决的问题。

---

## Module 1: 编译原理基础与 GCC 架构

### 1.1 核心概念速查
*   **编译流程**:
    *   **词法分析**: 将源代码转换为标记(Token)流
    *   **语法分析**: 构建语法树(Abstract Syntax Tree, AST)
    *   **语义分析**: 检查语义正确性，构建符号表
    *   **中间代码生成**: 生成平台无关的中间表示(IR)
    *   **优化**: 对中间代码进行各种优化
    *   **目标代码生成**: 生成目标平台的机器代码
*   **GCC 架构**:
    *   **前端(Frontend)**: 负责特定语言的解析和中间代码生成
    *   **中端(Middle-end)**: 负责中间代码优化，与语言和目标平台无关
    *   **后端(Backend)**: 负责目标代码生成和平台相关优化
*   **RISC-V 基础**:
    *   **指令集架构**: 加载-存储架构，32位/64位变体
    *   **寄存器**: 32个通用寄存器(x0-x31)，x0恒为0
    *   **指令格式**: R型(寄存器-寄存器)、I型(立即数)、S型(存储)、B型(分支)、U型(长立即数)、J型(跳转)

### 1.2 重点难点记录
- [ ] GCC 前后端分离架构的具体实现方式是什么？
- [ ] RISC-V 指令集的模块化设计如何影响编译器开发？
- [ ] 中间表示(IR)在编译流程中的作用是什么？为什么需要 IR？

### 1.3 实验记录
*   **GCC/RISC-V 工具链安装**:
    *   安装了 riscv64-unknown-elf-gcc 交叉编译工具链
    *   配置了环境变量，确保可以在命令行中使用
*   **编译流程实践**:
    *   使用 `gcc -E` 查看预处理结果
    *   使用 `gcc -S` 生成汇编代码
    *   使用 `gcc -c` 生成目标文件
    *   使用 `gcc -o` 生成可执行文件
*   **工具使用**:
    *   使用 `objdump -d` 反汇编可执行文件
    *   使用 `readelf -a` 查看 ELF 文件结构

---

## Module 2: GCC 后端架构与中间表示

### 2.1 核心概念速查
*   **GCC 中间表示**:
    *   **GIMPLE**: 高级中间表示，接近源代码结构
    *   **RTL(Register Transfer Language)**: 低级中间表示，接近目标平台指令
*   **GCC 后端文件结构**:
    *   **riscv.md**: 指令模式定义文件
    *   **riscv.c**: 目标平台特定的代码生成函数
    *   **riscv-protos.h**: 函数原型声明
    *   **riscv.opt**: 命令行选项定义
*   **RTL 基本结构**:
    *   **表达式(Expression)**: 表示操作数和操作
    *   **指令(Insn)**: 表示一条 RTL 指令
    *   **模式(Pattern)**: 用于指令选择的 RTL 模板

### 2.2 重点难点记录
- [ ] GIMPLE 和 RTL 的区别是什么？它们分别适合进行哪种优化？
- [ ] RTL 的表达式结构是怎样的？如何理解 RTL 指令？
- [ ] riscv.md 文件中的指令模式是如何定义的？

### 2.3 实验记录
*   **中间表示分析**:
    *   使用 `-fdump-tree-gimple` 生成 GIMPLE 表示
    *   使用 `-fdump-rtl-all` 生成 RTL 表示
    *   分析 GIMPLE 到 RTL 的转换过程
*   **GCC 源码分析**:
    *   查看 GCC 源码目录结构
    *   定位 RISC-V 后端相关文件
    *   分析 riscv.md 中的指令模式定义

---

## Module 3: GCC 指令选择与目标代码生成

### 3.1 核心概念速查
*   **指令选择**:
    *   **模式匹配**: 将 RTL 指令与目标平台指令模式匹配
    *   **指令组合**: 多个简单 RTL 指令组合成复杂目标指令
    *   **成本模型**: 选择最优的指令组合
*   **指令模式定义**:
    *   **define_insn**: 定义普通指令
    *   **define_expand**: 定义可扩展指令
    *   **define_split**: 定义指令拆分规则
    *   **define_peephole**: 定义窥孔优化规则
*   **代码生成过程**:
    *   从 RTL 指令到目标指令的映射
    *   寄存器分配前的代码准备
    *   最终机器码的生成

### 3.2 重点难点记录
- [ ] GCC 指令选择的算法是什么？如何工作？
- [ ] 如何在 riscv.md 中定义有效的指令模式？
- [ ] 指令组合和指令拆分会对代码质量产生什么影响？

### 3.3 实验记录
*   **指令模式分析**:
    *   分析 riscv.md 中的基本指令模式
    *   理解指令模式中的条件和约束
    *   查看指令模式生成的汇编代码
*   **代码生成跟踪**:
    *   使用调试工具跟踪指令选择过程
    *   分析特定 C 代码片段的代码生成过程
    *   比较不同优化级别下的代码生成结果

---

## Module 4: 寄存器分配与指令调度

### 4.1 核心概念速查
*   **寄存器分配**:
    *   **图着色算法**: 将变量映射到寄存器的经典算法
    *   **活跃变量分析**: 确定变量的活跃范围
    *   **冲突图**: 表示变量之间的寄存器冲突关系
    *   **溢出处理**: 当寄存器不足时将变量溢出到内存
*   **指令调度**:
    *   **流水线优化**: 减少流水线停顿
    *   **依赖分析**: 识别指令之间的数据依赖和控制依赖
    *   **调度算法**: 列表调度、循环调度等
*   **RISC-V 寄存器模型**:
    *   **参数寄存器**: a0-a7 (x10-x17) 用于传递参数
    *   **返回值寄存器**: a0-a1 (x10-x11) 用于返回结果
    *   **临时寄存器**: t0-t6 (x5-x7, x28-x31) 不需要保存
    *   **保存寄存器**: s0-s11 (x8-x9, x18-x27) 需要保存/恢复

### 4.2 重点难点记录
- [ ] 图着色寄存器分配算法的具体实现细节是什么？
- [ ] 如何在 GCC 中调整寄存器分配策略？
- [ ] 指令调度如何与寄存器分配相互影响？

### 4.3 实验记录
*   **寄存器分配分析**:
    *   使用 `-fdump-regalloc` 查看寄存器分配过程
    *   分析变量溢出到内存的情况
    *   比较不同优化级别下的寄存器分配结果
*   **指令调度实验**:
    *   分析流水线停顿情况
    *   查看指令调度后的代码变化
    *   测量指令调度对性能的影响

---

## Module 5: 自定义指令集扩展与后端修改

### 5.1 核心概念速查
*   **RISC-V 自定义扩展**:
    *   **X 扩展**: 自定义指令扩展的标准命名空间
    *   **指令编码**: 使用未分配的操作码空间
    *   **ABI 兼容性**: 确保与标准 RISC-V 代码的兼容性
*   **GCC 后端修改流程**:
    *   **更新 riscv.md**: 添加新指令的模式定义
    *   **修改 riscv.c**: 添加指令处理函数
    *   **更新头文件**: 声明新函数和宏
    *   **配置文件修改**: 更新相关配置
*   **指令实现要点**:
    *   **操作码定义**: 为新指令分配唯一操作码
    *   **约束定义**: 定义指令的寄存器和操作数约束
    *   **汇编输出**: 定义指令的汇编格式
    *   **机器码生成**: 定义指令的二进制编码

### 5.2 重点难点记录
- [ ] 如何设计高效的自定义指令？
- [ ] GCC 后端修改后如何进行测试和验证？
- [ ] 自定义指令如何与现有指令集协同工作？

### 5.3 实验记录
*   **自定义指令设计**:
    *   设计了特定算法的加速指令
    *   定义了指令的操作码和编码格式
    *   制定了指令的语义规范
*   **GCC 后端修改**:
    * 在 riscv.md 中添加了新指令的模式定义
    * 在 riscv.c 中实现了指令处理函数
    * 更新了相关头文件和配置
*   **测试验证**:
    * 编写了测试程序验证新指令
    * 检查生成的汇编代码是否正确
    * 在模拟器上测试指令功能

---

## Module 6: 链接器与 ELF 文件格式

### 6.1 核心概念速查
*   **ELF 文件格式**:
    *   **ELF 头部**: 包含文件类型、机器类型、入口点等信息
    *   **节表(Section Header Table)**: 描述文件中的各个节
    *   **程序头表(Program Header Table)**: 描述进程镜像中的段
    *   **符号表(Symbol Table)**: 包含函数、变量等符号信息
    *   **重定位表(Relocation Table)**: 包含需要重定位的位置信息
*   **链接过程**:
    *   **符号解析**: 解析目标文件中的符号引用
    *   **重定位**: 调整符号的地址引用
    *   **地址分配**: 为各个节分配最终的内存地址
    *   **段合并**: 将相似的节合并到同一个段中
*   **RISC-V ELF 特性**:
    *   **特殊节**: .riscv.attributes 等
    *   **重定位类型**: R_RISCV_32, R_RISCV_JAL, R_RISCV_CALL 等
    *   **目标属性**: 表示 RISC-V 子扩展支持情况

### 6.2 重点难点记录
- [ ] 链接器如何解析和解决符号引用？
- [ ] 重定位的具体过程是什么？为什么需要重定位？
- [ ] ELF 文件中的节和段有什么区别？

### 6.3 实验记录
*   **ELF 文件分析**:
    * 使用 `readelf -a` 查看 ELF 文件的完整结构
    * 使用 `objdump -t` 查看符号表
    * 使用 `objdump -r` 查看重定位表
*   **链接过程实践**:
    * 手动编译多个源文件生成目标文件
    * 使用 `ld` 链接器手动链接目标文件
    * 编写简单的链接脚本控制内存布局
*   **重定位分析**:
    * 分析不同类型的重定位条目
    * 理解重定位过程中地址的计算方式
    * 查看重定位前后的代码变化

---

## Module 7: 编译器测试与验证

### 7.1 核心概念速查
*   **编译器测试方法**:
    *   **单元测试**: 测试编译器的各个组件
    *   **集成测试**: 测试编译器的整体功能
    *   **回归测试**: 确保修改不会破坏现有功能
    *   **性能测试**: 测试编译器生成代码的性能
*   **测试套件**:
    *   **GCC testsuite**: GCC 官方测试套件
    *   **RISC-V testsuite**: RISC-V 架构测试套件
    *   **自定义测试**: 针对特定功能的测试用例
*   **模拟验证**:
    *   **QEMU**: 通用机器模拟器，支持 RISC-V
    *   **Spike**: RISC-V ISA 参考模拟器
    *   **FPGA 验证**: 在实际硬件上验证

### 7.2 重点难点记录
- [ ] 如何构建有效的编译器测试套件？
- [ ] 如何定位和调试编译器生成的错误代码？
- [ ] 如何在没有实际硬件的情况下验证自定义指令？

### 7.3 实验记录
*   **测试套件使用**:
    * 运行 GCC testsuite 测试基本功能
    * 运行 RISC-V testsuite 测试指令集兼容性
    * 编写自定义测试用例验证特殊功能
*   **模拟器验证**:
    * 使用 QEMU 运行生成的可执行文件
    * 使用 Spike 验证指令执行的正确性
    * 对比不同模拟器的执行结果
*   **性能分析**:
    * 使用性能分析工具测量生成代码的性能
    * 比较优化前后的性能差异
    * 分析性能瓶颈并提出改进方案

---

## 综合项目记录

### 项目目标
为自研 RISC-V 软核构建完整的 GCC 编译器后端支持

### 项目规划
1. **指令集定义**: 确定软核支持的完整指令集
2. **GCC 后端开发**: 实现指令集的编译器支持
3. **链接器支持**: 确保正确的 ELF 文件生成
4. **测试验证**: 全面测试编译器功能
5. **性能优化**: 优化代码生成质量

### 项目进展
- [ ] 指令集定义完成
- [ ] GCC 后端基础框架搭建
- [ ] 核心指令支持实现
- [ ] 自定义指令支持实现
- [ ] 测试套件建立
- [ ] 性能优化完成

### 遇到的问题与解决方案
| 问题 | 解决方案 |
|------|----------|
| | |
| | |
| | |

### 项目总结


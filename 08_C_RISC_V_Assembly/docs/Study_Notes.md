# 学习笔记：C语言与RISC-V汇编语言 (C Language and RISC-V Assembly)

这份文档用于记录《C语言与RISC-V汇编语言》课程的学习心得、核心概念整理、实验记录以及待解决的问题。

---

## Module 1: C语言核心与编译基础

### 1.1 核心概念速查
*   **C语言基础**:
    *   **数据类型**: char (1字节), short (2字节), int (4字节), long (4/8字节), float (4字节), double (8字节)
    *   **指针**: 指向内存地址的变量，通过 `*` 解引用，`&` 取地址
    *   **数组**: 连续内存空间，数组名即首地址，支持随机访问 O(1)
    *   **函数**: 模块化代码单元，支持参数传递（值传递、指针传递）和返回值
*   **编译过程**:
    *   **预处理**: 处理 `#include`, `#define` 等预处理指令，生成 `.i` 文件
    *   **编译**: 将C代码编译为汇编代码，生成 `.s` 文件
    *   **汇编**: 将汇编代码转换为机器码，生成 `.o` 文件
    *   **链接**: 链接多个目标文件和库，生成可执行文件
*   **RISC-V架构概述**:
    *   **指令集**: RISC (精简指令集)，固定长度32位指令
    *   **寄存器**: 32个通用寄存器 (x0-x31)，x0恒为0
    *   **内存模型**: 字节寻址，小端序存储

### 1.2 重点难点记录
- [ ] 指针与数组的区别和联系是什么？
- [ ] C语言中的内存分配方式有哪些？各自的特点是什么？
- [ ] 预处理指令 `#define` 和 `typedef` 的区别是什么？

### 1.3 实验记录
*   **编译工具链安装**: 
    *   安装了RISC-V GCC工具链 (riscv64-unknown-elf-gcc)
    *   配置了环境变量，确保可以在命令行中使用
*   **C程序编译实践**:
    *   编写了简单的C程序，包含变量、数组、函数和指针
    *   使用 `gcc -S` 生成汇编代码，分析编译过程
    *   使用 `gcc -o` 生成可执行文件并运行

---

## Module 2: RISC-V汇编语言基础

### 2.1 核心概念速查
*   **RISC-V寄存器**:
    *   **通用寄存器**: x0-x31，其中 x0 恒为0，x1用于返回地址，x2用于栈指针
    *   **命名规范**: 如 x1 (ra), x2 (sp), x3 (gp), x4 (tp), x5-x7 (t0-t2), x8-x9 (s0-s1), x10-x17 (a0-a7)等
*   **基础指令**:
    *   **加载/存储**: lw (加载字), sw (存储字), lb (加载字节), sb (存储字节)
    *   **算术/逻辑**: add, sub, and, or, xor, sll (左移), srl (右移), sra (算术右移)
    *   **分支/跳转**: beq, bne, blt, bge, jal (跳转并链接), jalr (跳转并链接寄存器)
*   **汇编程序结构**:
    *   **数据段**: .data 定义初始化的数据
    *   **代码段**: .text 定义程序指令
    *   **符号定义**: .globl 定义全局符号

### 2.2 重点难点记录
- [ ] RISC-V寄存器的命名规范是什么？不同寄存器的用途是什么？
- [ ] 加载/存储指令的偏移量是如何计算的？
- [ ] 分支指令和跳转指令的区别是什么？

### 2.3 实验记录
*   **汇编程序编写**:
    *   编写了简单的汇编程序，实现算术运算和条件判断
    *   使用 `as` 汇编器和 `ld` 链接器生成可执行文件
    *   使用 `objdump -d` 反汇编可执行文件，分析机器码
*   **指令执行实践**:
    *   跟踪了汇编指令的执行过程，理解寄存器状态变化
    *   学习了如何使用调试器 (gdb) 调试汇编程序

---

## Module 3: C与汇编的对应关系

### 3.1 核心概念速查
*   **函数调用约定**:
    *   **参数传递**: a0-a7用于传递前8个整数参数，其余参数通过栈传递
    *   **返回值**: a0用于返回整数，fa0用于返回浮点数
    *   **栈帧结构**: 包含返回地址、保存的寄存器、局部变量和参数
*   **变量存储**:
    *   **全局变量**: 存储在数据段 (.data 或 .bss)
    *   **局部变量**: 存储在栈上
    *   **静态变量**: 存储在数据段，生命周期贯穿整个程序
*   **编译优化**:
    *   **优化级别**: -O0 (无优化), -O1, -O2, -O3, -Os (大小优化)
    *   **常见优化**: 常量折叠、死代码消除、循环展开、内联函数

### 3.2 重点难点记录
- [ ] 函数调用时栈帧是如何建立和销毁的？
- [ ] 编译器如何处理C语言中的数组和指针？
- [ ] 不同优化级别对汇编代码的影响是什么？

### 3.3 实验记录
*   **C与汇编对应分析**:
    *   编写了包含函数调用、数组操作和指针操作的C程序
    *   使用 `gcc -S -fno-asynchronous-unwind-tables` 生成汇编代码
    *   对比C代码和汇编代码，分析对应关系
*   **函数调用栈分析**:
    *   跟踪了函数调用时寄存器的变化和栈帧的建立过程
    *   学习了如何在调试器中查看栈帧和寄存器状态

---

## Module 4: 高级汇编编程技术

### 4.1 核心概念速查
*   **浮点指令集**:
    *   **浮点寄存器**: f0-f31，用于浮点运算
    *   **浮点指令**: fadd.s, fsub.s, fmul.s, fdiv.s (单精度)
    *   **浮点比较**: f.eq.s, f.lt.s, f.le.s 等
*   **系统调用**:
    *   **ECALL指令**: 触发系统调用
    *   **系统调用号**: 存储在 a7 寄存器中
    *   **参数传递**: a0-a5 用于传递参数
    *   **常用系统调用**: 5 (read), 6 (write), 93 (exit)
*   **汇编优化**:
    *   **指令调度**: 重排指令以减少流水线停顿
    *   **循环展开**: 减少循环开销
    *   **寄存器分配**: 减少内存访问，提高性能

### 4.2 重点难点记录
- [ ] 浮点指令集与整数指令集的区别是什么？
- [ ] 如何使用系统调用进行输入输出操作？
- [ ] 汇编优化的基本原则是什么？如何衡量优化效果？

### 4.3 实验记录
*   **浮点运算实践**:
    *   编写了使用浮点指令的汇编程序，实现简单的浮点计算
    *   学习了浮点寄存器的使用和浮点指令的执行
*   **系统调用实践**:
    *   使用系统调用实现了简单的输入输出功能
    *   学习了如何处理字符串和文件操作
*   **汇编优化实践**:
    *   对简单的循环程序进行了优化，包括循环展开和指令调度
    *   测量了优化前后的性能差异

---

## Module 5: C与汇编混合编程

### 5.1 核心概念速查
*   **内联汇编**:
    *   **语法**: `asm volatile ("assembly code" : output operands : input operands : clobbers)`
    *   **约束符**: r (寄存器), m (内存), i (立即数), a (a0寄存器) 等
*   **外部汇编**:
    *   **C调用汇编**: 在C代码中声明汇编函数，在汇编文件中实现
    *   **汇编调用C**: 在汇编代码中使用 jal 指令调用C函数
*   **函数接口**:
    *   **参数传递**: 遵循RISC-V函数调用约定
    *   **数据类型**: 注意C数据类型与汇编数据类型的对应关系
    *   **内存管理**: 避免内存泄漏和野指针

### 5.2 重点难点记录
- [ ] 内联汇编的约束符有哪些？如何使用？
- [ ] C和汇编混合编程时需要注意哪些问题？
- [ ] 如何在C和汇编之间传递复杂数据结构？

### 5.3 实验记录
*   **内联汇编实践**:
    *   在C代码中嵌入汇编指令，实现高效的内存操作
    *   学习了内联汇编的语法和约束符的使用
*   **外部汇编实践**:
    *   实现了C调用汇编函数和汇编调用C函数的例子
    *   学习了函数接口的设计和参数传递
*   **性能调优实践**:
    *   识别程序中的热点代码，使用汇编进行优化
    *   对比优化前后的性能，分析优化效果

---

## Module 6: RISC-V高级特性与应用

### 6.1 核心概念速查
*   **特权级别**:
    *   **M-mode**: 机器模式，最高特权级别，用于初始化和异常处理
    *   **S-mode**:  supervisor模式，用于操作系统内核
    *   **U-mode**: 用户模式，用于应用程序
*   **异常与中断**:
    *   **异常**: 同步事件，如指令错误、页错误
    *   **中断**: 异步事件，如外部设备中断、时钟中断
    *   **处理流程**: 保存现场、处理异常/中断、恢复现场
*   **RV32与RV64**:
    *   **RV32**: 32位架构，寄存器和地址都是32位
    *   **RV64**: 64位架构，寄存器和地址都是64位
    *   **兼容性**: RV64支持RV32的所有指令，是向上兼容的

### 6.2 重点难点记录
- [ ] 不同特权级别的区别是什么？它们的用途是什么？
- [ ] 异常和中断的处理流程是什么？
- [ ] RV32和RV64的区别是什么？如何编写兼容两种架构的代码？

### 6.3 实验记录
*   **特权级别实践**:
    *   学习了不同特权级别的切换和使用
    *   了解了特权级别对指令执行的影响
*   **异常处理实践**:
    *   实现了简单的异常处理程序
    *   学习了异常向量表的设置和使用
*   **RV64编程实践**:
    *   编写了兼容RV32和RV64的代码
    *   学习了64位架构的特点和编程技巧